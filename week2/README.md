### Week2
(수정중)

1. 코딩 컨벤션을 잘 지키자.
ex) 애플 가이드, 구글 코딩 컨벤션, 스타일 쉐어 등...
꼭 따르지는 않아도 되지만, 본인이 짠 코드 내부에서 동일하게 구현하도록 노력하자.
(코딩은 혼자 하는 것이 아니기 때문에 꼭 지켜줘야 함.)

2. 접근 제어를 잘하자.
불필요한 권한을 주지 않고, 최소한의 권한만 부여할 수 있게끔 접근제어하자.

번외)
private var model: MemoryGame<String>
var cards: [MemoryGame<String>.Card] {
    model.cards
}

이런식으로 접근 제어 하는 것을 보통...선호?.... 근데 취향인듯함.
복수형 모델을 만들어줘도 좋음

3. 함수형 모델을 잘 사용하자.
함수를 매개변수로 보내서 타입을 알 수 있게끔 해보자.
Swift의 강력한 기능 중 하나는 함수를 매개변수로써 사용할 수 있다는 것이다.
이 점을 활용하여 코드를 작성해보자.
(우리 코드에서는 content를 초기화 할 때 사용했음.)

ex)
func doSomething(closure: () -> ()) {
    closure()
}


4. 클로저를 적극 활용하자.
트레일링 클로저도 잘 사용해보자.
트레일링 클로저란???
경량 문법 중 하나로, 함수의 마지막 파라미터가 클로저일 때, 이를 파라미터 값 형식이 아닌 함수 뒤에 붙여 작성하는 문법이다.
이 때, Argutment Label은 생략된다.

ex) 트레일링 클로저(Trailing Closure) 예시

doSomething () { () -> () in
    print("Hello!")
}

또한, 클로저에서 in을 활용하여 return부를 잘 구분하자.


5. 타입 추론을 잘 사용해보자.
Swift는 타입추론에 굉장히 능하기 때문에 활용하면 좋다.

6. // MARK: - Intent(s)를 코드를 작성해보자.
이 기능을 사용하면 코드가 어떻게 작성됐는지 한 눈에 보기 편하다.
---------------------------------------------------------------------------
수업 내용

[MVVM]
MVVM패턴은 무엇일까??
MVVM : Model - View - ViewModel 디자인 패턴

왜 MVVM패턴을 사용할까??
SwiftUI가 이 디자인 패턴에 최적화되어있기 때문이다.


[Model]
무슨 일은 하는 애인지?? 구현

특징
1. UI적인 요소에 완전히 독립적이어야 한다.
2. 데이터 + 로직트로 구성되어 있다. 즉, 모델 혼자서만으로도 뭐하는 놈인지 파악할 수 있어야 한다.
3. 유일한 원본이어야 한다. (View에 복사되는 등... 뭐가 원본인지 모르는 상황이 생기면 혼란스러워질 수 있다.)
4. ⭐️절대 SwiftUI같은 UI기능을 import해서는 안된다.
왜냐??? -> 1번에 나와있듯이 UI적인 요소와 완.전.히. 독립적이어야 하기 때문이다.

[View]
Model을 반영(표현)해준다.
ex) 이전 값과 현재 값이 바뀐 것을 반영해주는 등...과 같은 기능

특징
1. 모델을 반영한다.
2. 상태(State)를 지양한다.
3. 선언적(Declarative)이다. 즉, body만 찾으면 된다. (그래서 UI프로그램과 굉장히 잘 어울린다.)
4. 반응형이다. (모델의 변화를 바로 알아보고 뷰에 반영해야 하기 때문이다.)
5. View는 intent(의도) 함수를 호출하여 View Model에게 전달한다.

View에서 사용하는 것들
@ObservedObject : (프로퍼티 래퍼) -> 이 객체는 관찰될 것이다. (viewModel앞에 추가한다.)
@Binding
.onReceive
@EnvironmentObject
.envirionmentObeject

[ViewModel]
View를 Model에 묶는 역할 (View에서 모델의 데이터를 효율적으로 변경할 수 있게 해주는 역할이다.)

특징
1. 해석 역할 : View에 맞는 형태를 제공하기 위해 지저분한 변환 뷰를 ViewModel에 구현한다.
2. 문지기 역할 : View는 Model에 직접 요청하는 것이 아니라 ViewModel을 거쳐서 변화나 데이터를 알려준다.
(Model이 변하는지의 여부를 계속 알려야 한다. (이것을 Publish라고 부른다.) ViewModel에게 알리는 것이 아닌 앱 전체에 변화 여부를 알려 변화된 것에 관심있는 View는 구독(Subscribe)을 해 알림을 기다리다가, 알림이 오면 View를 재구성한다.-> 반응형
즉, 전체에 알리는(publish) 알림에 대해 관찰하고, 구독하고 있던 View는 알림에 대해 데이터를 받고 다시 View를 재구성한다.)

ViewModel에서 사용하는 것들
ObservableObject : 관찰되는 객체 -> var objectWillChange.send()를 통해 변화가 일어나는 것을 알려준다.
@Publishe : objectWillChange의 기능과 동일한데 앞에 추가하면 해당 변수를 계속 관찰할 수 있게 한다.
objectWillChange.send()

ViewModel이 class를 사용하는 이유??
-> 데이터를 공유할 수 있게 하는 역할이기 때문에 원본에 접근할 수 있게금 class를 사용한다.
(데이터 공유, 상속이 필요한 경우를 제외하고는 struct를 사용하게끔 한다.)

import SwiftUI를 사용하는 이유??
-> View적인 요소를 사용하기 때문에 채택한다.




---------------------------------------------------------------------------
struct는 기본적으로 변경하지 않는다.
그래서 mutating을 넣어서 변경하지 않는 것을 알려야 한다.

---------------------------------------------------------------------------

옵셔널이 왜 enum타입인지 공부해보자.

---------------------------------------------------------------------------

옵셔녈 언래핑 하는 방법 공부해보자. (3가지)

---------------------------------------------------------------------------

static은 초기화 할 때나 같은 static계열에서는 바로 사용 가능하다.
ex)
static let emojis = {~~~~~}
static func createEmojiMemoryGame() => MemoryGame<String> {
    MemoryGame<String> (numberOfParisOfCard: 4) { pairIndex in emojis[pairIndex] }
}
private var model = createEmojiMemoryGame()

---------------------------------------------------------------------------
<FeedBack>
접근제어 의무화
internal private(set) var : 외부에서 읽기만 가능하고, 내부에서는 쓰기가 가능하도록 하는 간결한 코드(getter, setter)
internal은 생략해도 무방. 읽기는 internal, 쓰기는 private로 접근 제한이 정의된 프로퍼티 id





----------------------------------------------------------------------------
<미구현>
MemoryGame(Model)
- point 연산 부분 다시 구현하기.
